<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CW Decoder Protocol Test</title>
  <style>
    body {
      font-family: 'Courier New', monospace;
      max-width: 1200px;
      margin: 20px auto;
      padding: 20px;
      background: #1a1a1a;
      color: #00ff00;
    }
    h1 {
      color: #00ff00;
      text-align: center;
    }
    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 20px;
    }
    .panel {
      background: #000;
      border: 2px solid #00ff00;
      border-radius: 8px;
      padding: 20px;
    }
    .panel h2 {
      margin-top: 0;
      color: #00ffff;
      font-size: 18px;
      border-bottom: 1px solid #00ff00;
      padding-bottom: 10px;
    }
    .decoded-text {
      font-size: 24px;
      font-weight: bold;
      min-height: 100px;
      padding: 15px;
      background: #0a0a0a;
      border: 1px solid #00ff00;
      border-radius: 4px;
      word-wrap: break-word;
      margin-bottom: 15px;
    }
    .log {
      font-size: 12px;
      max-height: 400px;
      overflow-y: auto;
      padding: 10px;
      background: #0a0a0a;
      border: 1px solid #00ff00;
      border-radius: 4px;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .log-entry {
      margin-bottom: 3px;
    }
    .log-event { color: #ffff00; }
    .log-element { color: #00ffff; }
    .log-space { color: #ff00ff; }
    .log-decoded { color: #00ff00; font-weight: bold; }
    .log-error { color: #ff0000; }
    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    button {
      background: #00ff00;
      color: #000;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      font-family: 'Courier New', monospace;
    }
    button:hover {
      background: #00ffff;
    }
    button:active {
      background: #00cc00;
    }
    .stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-top: 15px;
    }
    .stat {
      background: #0a0a0a;
      padding: 10px;
      border: 1px solid #00ff00;
      border-radius: 4px;
      text-align: center;
    }
    .stat-label {
      font-size: 11px;
      color: #888;
    }
    .stat-value {
      font-size: 20px;
      font-weight: bold;
      color: #00ffff;
    }
  </style>
</head>
<body>
  <h1>CW Decoder Protocol Test</h1>
  
  <div class="controls">
    <button onclick="testWord('CQ')">Test: CQ</button>
    <button onclick="testWord('TEST')">Test: TEST</button>
    <button onclick="testWord('HELLO WORLD')">Test: HELLO WORLD</button>
    <button onclick="testSingleChar('E')">Test: E (dit)</button>
    <button onclick="testSingleChar('T')">Test: T (dah)</button>
    <button onclick="testBurst()">Test: Burst Arrival</button>
    <button onclick="clearDecoder()">Clear</button>
  </div>
  
  <div class="container">
    <div class="panel">
      <h2>Decoded Output</h2>
      <div class="decoded-text" id="decoded"></div>
      
      <div class="stats">
        <div class="stat">
          <div class="stat-label">WPM</div>
          <div class="stat-value" id="wpm">0</div>
        </div>
        <div class="stat">
          <div class="stat-label">Avg Dit</div>
          <div class="stat-value" id="avgDit">0ms</div>
        </div>
        <div class="stat">
          <div class="stat-label">Events</div>
          <div class="stat-value" id="eventCount">0</div>
        </div>
      </div>
    </div>
    
    <div class="panel">
      <h2>Event Log</h2>
      <div class="log" id="log"></div>
    </div>
  </div>

  <script src="public/js/cw-decoder.js"></script>
  <script>
    // Initialize decoder
    const decoder = new CWDecoder();
    const callsign = 'TEST';
    let eventCount = 0;
    
    // Setup callbacks
    decoder.onDecodedChar = (callsign, char, wpm) => {
      const decodedDiv = document.getElementById('decoded');
      decodedDiv.textContent += char;
      document.getElementById('wpm').textContent = wpm;
      const user = decoder.users.get(callsign);
      if (user) {
        document.getElementById('avgDit').textContent = user.avgDit.toFixed(1) + 'ms';
      }
      logEvent('DECODED: ' + char, 'log-decoded');
    };
    
    decoder.onWordSpace = (callsign) => {
      const decodedDiv = document.getElementById('decoded');
      decodedDiv.textContent += ' ';
      logEvent('WORD SPACE', 'log-space');
    };
    
    // Override console.log to capture decoder logs
    const originalLog = console.log;
    console.log = function(...args) {
      originalLog.apply(console, args);
      const msg = args.join(' ');
      
      if (msg.includes('[Decoder]')) {
        let className = 'log-entry';
        if (msg.includes('Processing event:')) className += ' log-event';
        else if (msg.includes('Element:')) className += ' log-element';
        else if (msg.includes('SPACE')) className += ' log-space';
        else if (msg.includes('DECODED:')) className += ' log-decoded';
        else if (msg.includes('ERROR')) className += ' log-error';
        
        logEvent(msg.replace('[Decoder] ', ''), className);
      }
    };
    
    function logEvent(msg, className = 'log-entry') {
      const logDiv = document.getElementById('log');
      const entry = document.createElement('div');
      entry.className = className;
      entry.textContent = msg;
      logDiv.appendChild(entry);
      logDiv.scrollTop = logDiv.scrollHeight;
    }
    
    // Morse code timing (25 WPM = 48ms dit)
    const WPM = 25;
    const DIT_MS = 1200 / WPM; // 48ms
    const DAH_MS = DIT_MS * 3; // 144ms
    const ELEMENT_SPACE = DIT_MS; // 48ms
    const LETTER_SPACE = DIT_MS * 3; // 144ms
    const WORD_SPACE = DIT_MS * 7; // 336ms
    
    // Morse code table
    const MORSE_TABLE = {
      'A': '.-',   'B': '-...', 'C': '-.-.', 'D': '-..',  'E': '.',
      'F': '..-.', 'G': '--.',  'H': '....', 'I': '..',   'J': '.---',
      'K': '-.-',  'L': '.-..', 'M': '--',   'N': '-.',   'O': '---',
      'P': '.--.', 'Q': '--.-', 'R': '.-.',  'S': '...',  'T': '-',
      'U': '..-',  'V': '...-', 'W': '.--',  'X': '-..-', 'Y': '-.--',
      'Z': '--..',
      '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-',
      '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.'
    };
    
    // Send event using CORRECTED protocol
    function sendEvent(key_down, duration_ms, delay_ms = 0) {
      setTimeout(() => {
        const event = {
          callsign: callsign,
          key_down: key_down,
          duration_ms: duration_ms,
          timestamp_ms: Date.now() - startTime,
          sequence: eventCount++
        };
        
        document.getElementById('eventCount').textContent = eventCount;
        decoder.processEvent(event);
      }, delay_ms);
    }
    
    let startTime = Date.now();
    
    // Encode and send a character
    function sendCharacter(char, delay_ms = 0) {
      const pattern = MORSE_TABLE[char.toUpperCase()];
      if (!pattern) return delay_ms;
      
      logEvent('Sending character: ' + char + ' (' + pattern + ')');
      
      for (let i = 0; i < pattern.length; i++) {
        const element = pattern[i];
        const elementDuration = (element === '.') ? DIT_MS : DAH_MS;
        
        // Transition TO DOWN (was UP for previous space duration)
        const prevSpaceDuration = (i === 0) ? 0 : ELEMENT_SPACE;
        sendEvent(true, prevSpaceDuration, delay_ms);
        delay_ms += 0; // Send immediately (simulation)
        
        // Transition TO UP (was DOWN for element duration)
        sendEvent(false, elementDuration, delay_ms);
        delay_ms += 0;
      }
      
      // Add letter space after character
      return delay_ms;
    }
    
    // Send a word
    function sendWord(word, delay_ms = 0) {
      for (let i = 0; i < word.length; i++) {
        const char = word[i];
        if (char === ' ') {
          // Send DOWN with previous WORD_SPACE duration
          sendEvent(true, WORD_SPACE, delay_ms);
        } else {
          delay_ms = sendCharacter(char, delay_ms);
          // Send DOWN transition with LETTER_SPACE (start of next char)
          if (i < word.length - 1 && word[i + 1] !== ' ') {
            sendEvent(true, LETTER_SPACE, delay_ms);
          }
        }
      }
      
      logEvent('=== Transmission complete ===');
    }
    
    // Test functions
    function testWord(word) {
      clearDecoder();
      startTime = Date.now();
      logEvent('=== Testing: ' + word + ' ===', 'log-event');
      sendWord(word);
    }
    
    function testSingleChar(char) {
      clearDecoder();
      startTime = Date.now();
      logEvent('=== Testing single char: ' + char + ' ===', 'log-event');
      sendCharacter(char, 0);
    }
    
    function testBurst() {
      clearDecoder();
      startTime = Date.now();
      logEvent('=== Testing BURST arrival (all packets in <5ms) ===', 'log-event');
      logEvent('This simulates WiFi/TCP burst behavior');
      
      // Send "CQ" but with all events arriving at once
      const events = [];
      let ts = 0;
      
      // C = -.-.
      events.push({ key_down: true, duration_ms: 0, timestamp_ms: ts });
      events.push({ key_down: false, duration_ms: DAH_MS, timestamp_ms: ts + DAH_MS });
      ts += DAH_MS;
      
      events.push({ key_down: true, duration_ms: ELEMENT_SPACE, timestamp_ms: ts + ELEMENT_SPACE });
      events.push({ key_down: false, duration_ms: DIT_MS, timestamp_ms: ts + ELEMENT_SPACE + DIT_MS });
      ts += ELEMENT_SPACE + DIT_MS;
      
      events.push({ key_down: true, duration_ms: ELEMENT_SPACE, timestamp_ms: ts + ELEMENT_SPACE });
      events.push({ key_down: false, duration_ms: DAH_MS, timestamp_ms: ts + ELEMENT_SPACE + DAH_MS });
      ts += ELEMENT_SPACE + DAH_MS;
      
      events.push({ key_down: true, duration_ms: ELEMENT_SPACE, timestamp_ms: ts + ELEMENT_SPACE });
      events.push({ key_down: false, duration_ms: DIT_MS, timestamp_ms: ts + ELEMENT_SPACE + DIT_MS });
      ts += ELEMENT_SPACE + DIT_MS;
      
      // Letter space
      events.push({ key_down: true, duration_ms: LETTER_SPACE, timestamp_ms: ts + LETTER_SPACE });
      ts += LETTER_SPACE;
      
      // Q = --.-
      events.push({ key_down: false, duration_ms: DAH_MS, timestamp_ms: ts + DAH_MS });
      ts += DAH_MS;
      
      events.push({ key_down: true, duration_ms: ELEMENT_SPACE, timestamp_ms: ts + ELEMENT_SPACE });
      events.push({ key_down: false, duration_ms: DAH_MS, timestamp_ms: ts + ELEMENT_SPACE + DAH_MS });
      ts += ELEMENT_SPACE + DAH_MS;
      
      events.push({ key_down: true, duration_ms: ELEMENT_SPACE, timestamp_ms: ts + ELEMENT_SPACE });
      events.push({ key_down: false, duration_ms: DIT_MS, timestamp_ms: ts + ELEMENT_SPACE + DIT_MS });
      ts += ELEMENT_SPACE + DIT_MS;
      
      events.push({ key_down: true, duration_ms: ELEMENT_SPACE, timestamp_ms: ts + ELEMENT_SPACE });
      events.push({ key_down: false, duration_ms: DAH_MS, timestamp_ms: ts + ELEMENT_SPACE + DAH_MS });
      
      // Send all events at once (burst arrival)
      logEvent('Sending ' + events.length + ' events in burst...');
      events.forEach((event, i) => {
        event.callsign = callsign;
        event.sequence = i;
        setTimeout(() => {
          decoder.processEvent(event);
        }, i * 2); // Very short delay (2ms) simulates burst
      });
      
      logEvent('All events sent! Duration_ms encodes timing, not arrival time.');
    }
    
    function clearDecoder() {
      document.getElementById('decoded').textContent = '';
      document.getElementById('log').textContent = '';
      document.getElementById('wpm').textContent = '0';
      document.getElementById('avgDit').textContent = '0ms';
      document.getElementById('eventCount').textContent = '0';
      decoder.clear();
      eventCount = 0;
      startTime = Date.now();
    }
    
    // Auto-test on load
    logEvent('=== Decoder Ready ===', 'log-event');
    logEvent('Protocol: key_down = NEW state, duration_ms = PREVIOUS state duration');
    logEvent('Click a test button to begin...');
  </script>
</body>
</html>
